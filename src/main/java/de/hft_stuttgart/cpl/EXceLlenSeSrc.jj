options
        {
        IGNORE_CASE = true;
        STATIC = false;
        }
PARSER_BEGIN(EXceLlenSe)
package de.hft_stuttgart.cpl;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.HashMap;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import java.lang.String;
import java.util.List;
import java.util.ArrayList;
public class EXceLlenSe
{
    private static Map<String, String> cellReferenceValues;
    private static CurrentLoop currentLoop = null;

    private class CurrentLoop{
        public int loopStart;
        public int loopEnd;
    }

    private static String convertToString(double value) {
        if (value == (long) value) {
            return String.format("%d", (long) value);
        } else {
            return String.format("%s", value);
        }
    }

    private static String convertToString(boolean value) {
        if (value) {
            return "TRUE";
        } else {
            return "FALSE";
        }
    }

    public static void main(String args[]) throws ParseException, IOException
    {
            try {
                cellReferenceValues = new HashMap<>();
                EXceLlenSe parser = new EXceLlenSe(System.in);
                parser.program();
                System.out.println("Parsing successful!");
                System.out.println("Dump Variables: ");
                for (String key : cellReferenceValues.keySet()) {
                    System.out.println(key + " = " + cellReferenceValues.get(key));
                }
            } catch (ParseException e) {
                System.out.println("Parsing error: " + e.getMessage());
            }
    }
}
    PARSER_END(EXceLlenSe)
SKIP:
        {
        " "
        |   "\r"
        |   "\t"
        |   "\n"
        }
TOKEN:
        {
          < EQ: "=" >
        | < FORMATTED: "FORMATTED" >
        | < FOR: "for" >
        | < FROM: "from" >
        | < TO: "to" >
        | < DO: "do" >
        | < END: "end" >
        | < FUNCTION: "countFunc" >
        | < CONCAT: "&" >
        | < ADD: "+" >
        | < SUB: "-" >
        | < MOD: "%" >
        | < DIV: "/" >
        | < MUL: "*" >
        | < DECIMAL_LITERAL: ("+" | "-")? (["1"-"9"])(["0"-"9"])* >
        | < FLOAT_LITERAL_1: ("+" | "-")? (["0"-"9"])+ ("E" ("+" | "-")? (["0"-"9"])+) >
        | < FLOAT_LITERAL_2: ("+" | "-")? "." (["0"-"9"])+ ("E" ("+" | "-")? (["0"-"9"])+)? >
        | < FLOAT_LITERAL_3: ("+" | "-")? (["0"-"9"])+ "." (["0"-"9"])* ("E" ("+" | "-")? (["0"-"9"])+)? >
        | < STRING_LITERAL: "'" ("''" | ~["'"])* "'" >
        | < TIMESTAMP_LITERAL: "{" ["0"-"9"] ["0"-"9"] ["0"-"9"] ["0"-"9"] "-" ["0"-"9"] ["0"-"9"] "-" ["0"-"9"] ["0"-"9"] " " ["0"-"9"] ["0"-"9"] ":" ["0"-"9"] ["0"-"9"] ":" ["0"-"9"] ["0"-"9"] "}">
        | < VARIABLE: ("i" | "j" | "k" | "l" | "m" | "n") >
        | < COMP_OP: ("<" | "<=" | "=" | ">=" | ">" | "<>") >
        | < FINISH: "exit" >
        }

        void program():
        {} {
            (statement())* <FINISH>
        }
        void statement():
        {} {
            assignment() | forLoop()
        }

        List<String> cellReference():
        {
            List<String> exprColumn = new ArrayList<String>();
            List<String> exprRow = new ArrayList<String>();
            List<String> res = new ArrayList<String>();
} {
            "C"
            exprColumn = numberExpression()
            "R"
            exprRow = numberExpression()
            {
                 if(currentLoop != null)
                 {
                     for (int i = currentLoop.loopStart; i < currentLoop.loopEnd; i++)
                      {
                          String resultCell = "C" + exprColumn.get(i) + "R" + exprRow.get(i);
                          res.add(resultCell);
                      }

                 }
                 else
                 {
                     res.add("C" + exprColumn.get(0) + "R" + exprRow.get(0));
                 }

                 return res;
            }
        }

void assignment():
        {
            List<String> references;
            List<String> expressionValues;
                }
          {
            references = cellReference()
            <EQ>
            expressionValues = expression()
            [ <FORMATTED> stringExpression() ]
            {
                for (int i = 0; i < references.size(); i++)
                    cellReferenceValues.put(references.get(i), expressionValues.get(i));
            }
        }


        void forLoop():
        {} {
            {
                currentLoop = new CurrentLoop();
            }
            <FOR> <VARIABLE> <FROM> {currentLoop.loopStart = Integer.parseInt(expression().get(0));} <TO> {currentLoop.loopEnd = Integer.parseInt(expression().get(0));} <DO>
            {
                assignment();
            }
            <END>
            {
                currentLoop = null;
            }
        }

        List<String> expression():
        {
            String output = "";
            List<String> outputList = new ArrayList<String>();
        } {
                 LOOKAHEAD(12) output = booleanExpression()
                  {
                    outputList.add(output);
                    return outputList;
                  }
                  |
                 LOOKAHEAD(6) outputList = numberExpression()
                    {
                        return outputList;
                    }
                  |
                 LOOKAHEAD(6) output = timestampExpression()
                 {
                    outputList.add(output);
                    return outputList;
                 }
                 |
               LOOKAHEAD(12) outputList = stringExpression()
                 {
                     return outputList;
                 }
        }


        List<String> numberExpression():
        {
         List<String> firstTerm = new ArrayList<String>();
         List<String> secondTerm = new ArrayList<String>();
         List<String> res = new ArrayList<String>();
         String funcCallRes = "";
         String op = "";
         String timeStamp1 = "";
         String timeStamp2 = "";
        }
        {
            firstTerm = term()
            {
                for (int i = 0; i < firstTerm.size(); i++)
                {
                    res.add(firstTerm.get(i));
                }
            }
            (
            op = <ADD>.image
            secondTerm = term()
                 {
                    for (int i = 0; i < firstTerm.size(); i++){
                        Double firstTermDouble = Double.parseDouble(firstTerm.get(i));
                        Double secondTermDouble = Double.parseDouble(secondTerm.get(i));
                        String calcRes = convertToString(firstTermDouble + secondTermDouble);
                        res.add(calcRes);
                    }
                 }
            |
            op = <SUB>.image
            secondTerm = term()
                 {
                     for (int i = 0; i < firstTerm.size(); i++){
                        Double firstTermDouble = Double.parseDouble(firstTerm.get(i));
                        Double secondTermDouble = Double.parseDouble(secondTerm.get(i));
                        String calcRes = convertToString(firstTermDouble - secondTermDouble);
                        res.add(calcRes);
                    }
                 }
            )*
             {
                return res;
              }
              | funcCallRes = functionCall()
              {
                res.add(funcCallRes);
                return res;
              }
              |
              timeStamp1 = <TIMESTAMP_LITERAL>.image
              <SUB>
              timeStamp2 = <TIMESTAMP_LITERAL>.image
              {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                timeStamp1 = timeStamp1.replace("{", "");
                timeStamp1 = timeStamp1.replace("}", "");
                timeStamp2 = timeStamp2.replace("{", "");
                timeStamp2 = timeStamp2.replace("}", "");
                LocalDateTime dateTime1 = LocalDateTime.parse(timeStamp1, formatter);
                LocalDateTime dateTime2 = LocalDateTime.parse(timeStamp2, formatter);
                Duration duration = Duration.between(dateTime1, dateTime2);
                res.add(Long.toString(duration.getSeconds() * -1));
                return res;
              }
        }

                String booleanExpression():
                {
                 List<String> firstTermList;
                 List<String> secondTermList;
                String firstTerm = "";
                String secondTerm = "";
                String op = "";
                String res = "";
                String timeStamp1 = "";
                String timeStamp2 = "";
                }
                {
                LOOKAHEAD(3) firstTermList = numberExpression()
                op = <COMP_OP>.image
                secondTermList = numberExpression()
                {
                    firstTerm = firstTermList.get(0);
                    secondTerm = secondTermList.get(0);
                    Double firstTermDouble = Double.parseDouble(firstTerm);
                    Double secondTermDouble = Double.parseDouble(secondTerm);
                    switch (op) {
                        case "<":
                            res = convertToString(firstTermDouble < secondTermDouble);
                            break;
                        case "<=":
                            res = convertToString(firstTermDouble <= secondTermDouble);
                            break;
                        case "=":
                            res = convertToString(firstTermDouble.equals(secondTermDouble));
                            break;
                        case ">=":
                            res = convertToString(firstTermDouble >= secondTermDouble);
                            break;
                        case ">":
                            res = convertToString(firstTermDouble > secondTermDouble);
                            break;
                        case "<>":
                            res = convertToString(!firstTermDouble.equals(secondTermDouble));
                            break;
                    }
                    return res;
                }
                |
                LOOKAHEAD(3) timeStamp1 = <TIMESTAMP_LITERAL>.image
                op = <COMP_OP>.image
                timeStamp2 = <TIMESTAMP_LITERAL>.image
                {
                    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                    timeStamp1 = timeStamp1.replace("{", "");
                    timeStamp1 = timeStamp1.replace("}", "");
                    timeStamp2 = timeStamp2.replace("{", "");
                    timeStamp2 = timeStamp2.replace("}", "");
                    LocalDateTime dateTime1 = LocalDateTime.parse(timeStamp1, formatter);
                    LocalDateTime dateTime2 = LocalDateTime.parse(timeStamp2, formatter);
                    switch (op) {
                        case "<":
                            res = convertToString(dateTime1.isBefore(dateTime2));
                            break;
                        case "<=":
                            res = convertToString(dateTime1.isBefore(dateTime2) || dateTime1.isEqual(dateTime2));
                            break;
                        case "=":
                            res = convertToString(dateTime1.isEqual(dateTime2));
                            break;
                        case ">=":
                            res = convertToString(dateTime1.isAfter(dateTime2) || dateTime1.isEqual(dateTime2));
                            break;
                        case ">":
                            res = convertToString(dateTime1.isAfter(dateTime2));
                            break;
                        case "<>":
                            res = convertToString(!dateTime1.isEqual(dateTime2));
                            break;
                    }
                    return res;
                }
                |
                LOOKAHEAD(3) firstTermList = stringExpression()
                op = <COMP_OP>.image
                secondTermList = stringExpression()
                {
                    firstTerm = firstTermList.get(0);
                    secondTerm = secondTermList.get(0);
                    switch (op) {
                        case "<":
                            res = convertToString(firstTerm.compareTo(secondTerm) < 0);
                            break;
                        case "<=":
                            res = convertToString(firstTerm.compareTo(secondTerm) <= 0);
                            break;
                        case "=":
                            res = convertToString(firstTerm.compareTo(secondTerm) == 0);
                            break;
                        case ">=":
                            res = convertToString(firstTerm.compareTo(secondTerm) >= 0);
                            break;
                        case ">":
                            res = convertToString(firstTerm.compareTo(secondTerm) > 0);
                            break;
                        case "<>":
                            res = convertToString(firstTerm.compareTo(secondTerm) != 0);
                            break;
                    }
                    return res;
                }
            }

       List<String> term() :
       {
           String firstFactor = "";
           String secondFactor = "";
           String op = "";
           List<String> res = new ArrayList<String>();
       }
       {
           firstFactor = factor()
           {
              if (firstFactor.equals("< VARIABLE >") && currentLoop != null)
              {
                  for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                     res.add(firstFactor);
                 }
              }
              else
              {
                  res.add(firstFactor);
              }
           }
           (
               op = <MUL>.image
               secondFactor = factor()
               {
                   Double firstFactorDouble = 0.0;
                   Double secondFactorDouble = 0.0;

                   if (firstFactor.equals("< VARIABLE >") && !secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                       secondFactorDouble = Double.parseDouble(secondFactor);
                       for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                           res.add(convertToString((Double.valueOf(i)) * secondFactorDouble));
                       }
                   }
                   else if (!firstFactor.equals("< VARIABLE >") && secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                       firstFactorDouble = Double.parseDouble(firstFactor);
                       for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                           res.add(convertToString(firstFactorDouble * (Double.valueOf(i))));
                       }
                   }
                   else if (firstFactor.equals("< VARIABLE >") && secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                      for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                          res.add(convertToString( (Double.valueOf(i)) * (Double.valueOf(i)) ));
                      }
                   }
                   else if (!firstFactor.equals("< VARIABLE >") && !secondFactor.equals("< VARIABLE >")) {
                       res.add(convertToString(firstFactorDouble * secondFactorDouble));
                   }
               }
               |
               op = <DIV>.image
               secondFactor = factor()
               {
                       Double firstFactorDouble = 0.0;
                       Double secondFactorDouble = 0.0;

                       if (firstFactor.equals("< VARIABLE >") && !secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                           secondFactorDouble = Double.valueOf(secondFactor);
                           for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                               res.add(convertToString((Double.valueOf(i)) / secondFactorDouble));
                           }
                       }
                       else if (!firstFactor.equals("< VARIABLE >") && secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                           firstFactorDouble = Double.valueOf(firstFactor);
                           for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                               res.add(convertToString(firstFactorDouble / (Double.valueOf(i))));
                           }
                       }
                       else if (firstFactor.equals("< VARIABLE >") && secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                          for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                              res.add(convertToString( (Double.valueOf(i)) / (Double.valueOf(i)) ));
                          }
                       }
                       else if (!firstFactor.equals("< VARIABLE >") && !secondFactor.equals("< VARIABLE >")) {
                           res.add(convertToString(firstFactorDouble / secondFactorDouble));
                       }
               }
               |
               op = <MOD>.image
               secondFactor = factor()
               {
                 Double firstFactorDouble = 0.0;
                  Double secondFactorDouble = 0.0;

                  if (firstFactor.equals("< VARIABLE >") && !secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                      secondFactorDouble = Double.valueOf(secondFactor);
                      for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                          res.add(convertToString((Double.valueOf(i)) % secondFactorDouble));
                      }
                  }
                  else if (!firstFactor.equals("< VARIABLE >") && secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                      firstFactorDouble = Double.valueOf(firstFactor);
                      for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                          res.add(convertToString(firstFactorDouble % (Double.valueOf(i))));
                      }
                  }
                  else if (firstFactor.equals("< VARIABLE >") && secondFactor.equals("< VARIABLE >") && currentLoop != null) {
                     for (int i = currentLoop.loopStart; i <= currentLoop.loopEnd; i++) {
                         res.add(convertToString( (Double.valueOf(i)) % (Double.valueOf(i)) ));
                     }
                  }
                  else if (!firstFactor.equals("< VARIABLE >") && !secondFactor.equals("< VARIABLE >")) {
                      res.add(convertToString(firstFactorDouble % secondFactorDouble));
                  }
               }
           )*
           {
               return res;
           }
       }


        String factor():
        {
         String literal = "";
         } {
            literal = <DECIMAL_LITERAL>.image
             {
                return literal;
             }
            |
            literal = <FLOAT_LITERAL_1>.image
             {
                 return literal;
             }
            |
            literal = <FLOAT_LITERAL_2>.image
             {
                 return literal;
             }
            |
            literal = <FLOAT_LITERAL_3>.image
            {
                return literal;
            }
            |
            literal = <VARIABLE>.image
            {
                if(currentLoop != null)
                    return literal;
                return null;
            }
        }

        String argsList():
        {
         int count = 1;
         } {
            <DECIMAL_LITERAL>
            (
                ","
                <DECIMAL_LITERAL>
                {
                    count++;
                }
            )*
            {
                return Integer.toString(count);
            }
        }

        String functionCall():
        {String res = "";} {
            <FUNCTION>
            "("
            res = argsList()
            ")"
            {
             return res;
            }
        }

        String timestampExpression():
        {
         String timestamp = "";
         String op = "";
         List<String> numberList;
         String number = "";
} {
            LOOKAHEAD(3)
            timestamp = <TIMESTAMP_LITERAL>.image
             op = <ADD>.image
            numberList = numberExpression()
            {
                number = numberList.get(0);
                timestamp = timestamp.replace("{", "");
                timestamp = timestamp.replace("}", "");
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                LocalDateTime dateTime = LocalDateTime.parse(timestamp, formatter);
                dateTime = dateTime.plusSeconds(Long.parseLong(number));
                return dateTime.toString();
            }
              |
             LOOKAHEAD(3)
             timestamp = <TIMESTAMP_LITERAL>.image
              op = <SUB>.image
             numberList = numberExpression()
             {
                 number = numberExpression().get(0);
                timestamp = timestamp.replace("{", "");
                timestamp = timestamp.replace("}", "");
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
                LocalDateTime dateTime = LocalDateTime.parse(timestamp, formatter);
                dateTime = dateTime.minusSeconds(Long.parseLong(number));
                return dateTime.toString();
             }
        }

        List<String> stringExpression():
        {
            String currentLiteral = "";
            String ampresandSign = "";
            String concatLiteral = "";
            List<String> cellRefList;
            List<String> stringExprList = new ArrayList<String>();
            List<String> cellRefValueList = new ArrayList<String>();
} {
            currentLiteral = <STRING_LITERAL>.image
             (
              ampresandSign = <CONCAT>.image
              concatLiteral = <STRING_LITERAL>.image
              {
                currentLiteral = currentLiteral.replace("\'", "");
                concatLiteral = concatLiteral.replace("\'", "");
                currentLiteral = currentLiteral + " " + concatLiteral;
              }
              )*
              {
                currentLiteral = currentLiteral.replace("\'", "");
                cellRefValueList.add(currentLiteral);
                return cellRefValueList;
                }
            |
            cellRefList = cellReference()
            concatLiteral = <CONCAT>.image
            stringExprList = stringExpression()
            {
                if(currentLoop != null)
                {
                    for (int i = 0; i < cellRefList.size(); i++)
                    {
                        String cellRef = cellRefList.get(i);
                        String cellRefValue = cellReferenceValues.get(cellRef);
                        cellRefValue = cellRefValue + " " + (i >= stringExprList.size() ? stringExprList.get(stringExprList.size() - 1) : stringExprList.get(i));
                        cellRefValue = cellRefValue.replace("\'", "");
                        cellRefValueList.add(cellRefValue);
                    }
                }

                String cellRefValue = cellReferenceValues.get(0);
                cellRefValue = cellRefValue + " " + stringExprList.get(0);
                cellRefValue = cellRefValue.replace("\'", "");
                cellRefValueList.add(cellRefValue);
                return cellRefValueList;
            }
        }
